pipeline {
    agent any

    parameters {
        string(name: 'REPO_URL', defaultValue: 'https://github.com/SanctuaryV/community-platform-plus-backend.git', description: 'Git repo URL')
        string(name: 'REPO_BRANCH', defaultValue: 'main', description: 'Branch to checkout')
        string(name: 'IMAGE_NAME_BACKEND', defaultValue: 'community-platform-plus-backend', description: 'Docker image name for backend')
        string(name: 'N8N_WEBHOOK_URL', defaultValue: 'https://35.247.160.122:5678/webhook/627982e1-ee55-4a89-a91a-901e8436b313', description: 'n8n Test Webhook URL')
        booleanParam(name: 'Run_Checkmarx', defaultValue: false, description: 'Run Checkmarx scan')
    }

    environment {
        APP_REPO_URL = "${params.REPO_URL}"
        APP_REPO_BRANCH = "${params.REPO_BRANCH}"
        IMAGE_NAME_BACKEND = "${params.IMAGE_NAME_BACKEND}"
        IMAGE_TAG = "${BUILD_NUMBER}"
    }

    stages {
        stage('Clone Repository') {
            steps {
                cleanWs()
                git branch: "${APP_REPO_BRANCH}",
                    url: "${APP_REPO_URL}"
            }
        }

        stage('Install Dependencies') {
            steps {
                sh '''
                    echo "Installing dependencies..."
                    npm install
                '''
            }
        }

        stage('SAST - Checkmarx') {
            when {
                expression { return params.Run_Checkmarx == true }
            }
            steps {
                script {
                    try {
                        echo "üîç Running Checkmarx scan..."
                        
                        // Capture the console output during the scan
                        def logContent = ""
                        
                        // Run Checkmarx scan with custom output path
                        checkmarxASTScanner additionalOptions: '--project-groups intern --scan-types "sast,sca" --report-format sarif --output-name checkmarx --output-path reports',
                            baseAuthUrl: '',
                            branchName: "${APP_REPO_BRANCH}",
                            checkmarxInstallation: 'Checkmarx',
                            credentialsId: '',
                            projectName: "SanctuaryV/community-platform-plus-backend",
                            serverUrl: '',
                            tenantName: '',
                            useOwnAdditionalOptions: true
                        
                        // Get the console log to parse scan summary
                        echo "üìä Parsing Checkmarx scan summary from console output..."
                        logContent = currentBuild.rawBuild.getLog(1000).join('\n')
                        
                        // Parse scan summary from console output
                        def scanSummary = [:]
                        def vulnerabilities = [
                            SAST: [critical: 0, high: 0, medium: 0, low: 0, info: 0],
                            SCA: [critical: 0, high: 0, medium: 0, low: 0, info: 0],
                            IAC: [critical: 0, high: 0, medium: 0, low: 0, info: 0],
                            CONTAINERS: [critical: 0, high: 0, medium: 0, low: 0, info: 0],
                            SCS: [critical: 0, high: 0, medium: 0, low: 0, info: 0],
                            APIs: [critical: 0, high: 0, medium: 0, low: 0, info: 0]
                        ]
                        
                        // Parse the output for vulnerability data
                        logContent.eachLine { line ->
                            // Look for lines like: | SAST 0 0 1 43 0 Completed |
                            def matcher = line =~ /\|\s*(SAST|SCA|IAC|CONTAINERS|SCS|APIs)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+.*\|/
                            if (matcher.find()) {
                                def scanType = matcher.group(1)
                                vulnerabilities[scanType] = [
                                    critical: matcher.group(2).toInteger(),
                                    high: matcher.group(3).toInteger(),
                                    medium: matcher.group(4).toInteger(),
                                    low: matcher.group(5).toInteger(),
                                    info: matcher.group(6).toInteger()
                                ]
                            }
                            
                            // Parse total line: | TOTAL 0 6 1 46 0 Completed |
                            def totalMatcher = line =~ /\|\s*TOTAL\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+.*\|/
                            if (totalMatcher.find()) {
                                scanSummary.totalCritical = totalMatcher.group(1).toInteger()
                                scanSummary.totalHigh = totalMatcher.group(2).toInteger()
                                scanSummary.totalMedium = totalMatcher.group(3).toInteger()
                                scanSummary.totalLow = totalMatcher.group(4).toInteger()
                                scanSummary.totalInfo = totalMatcher.group(5).toInteger()
                            }
                            
                            // Parse Scan ID
                            if (line.contains('Scan ID:')) {
                                def scanIdMatcher = line =~ /Scan ID:\s*([a-f0-9-]+)/
                                if (scanIdMatcher.find()) {
                                    scanSummary.scanId = scanIdMatcher.group(1)
                                }
                            }
                            
                            // Parse Created At timestamp
                            if (line.contains('Created At:')) {
                                def dateMatcher = line =~ /Created At:\s*([\d-]+,\s*[\d:]+)/
                                if (dateMatcher.find()) {
                                    scanSummary.createdAt = dateMatcher.group(1)
                                }
                            }
                            
                            // Parse Project Name
                            if (line.contains('Project Name:')) {
                                def projectMatcher = line =~ /Project Name:\s*(.+)/
                                if (projectMatcher.find()) {
                                    scanSummary.projectName = projectMatcher.group(1).trim()
                                }
                            }
                            
                            // Parse Risk Level
                            if (line.contains('Risk Level:')) {
                                def riskMatcher = line =~ /Risk Level:\s*(\w+\s*\w*)/
                                if (riskMatcher.find()) {
                                    scanSummary.riskLevel = riskMatcher.group(1).trim()
                                }
                            }
                        }
                        
                        scanSummary.vulnerabilities = vulnerabilities
                        env.CHECKMARX_SCAN_SUMMARY = groovy.json.JsonOutput.toJson(scanSummary)
                        
                        echo "‚úÖ Parsed Checkmarx Scan Summary:"
                        echo "   Project: ${scanSummary.projectName ?: 'Unknown'}"
                        echo "   Scan ID: ${scanSummary.scanId ?: 'Unknown'}"
                        echo "   Created At: ${scanSummary.createdAt ?: 'Unknown'}"
                        echo "   Risk Level: ${scanSummary.riskLevel ?: 'Unknown'}"
                        echo "   Total Vulnerabilities - Critical: ${scanSummary.totalCritical ?: 0}, High: ${scanSummary.totalHigh ?: 0}, Medium: ${scanSummary.totalMedium ?: 0}, Low: ${scanSummary.totalLow ?: 0}"
                        echo "   SAST - Critical: ${vulnerabilities.SAST.critical}, High: ${vulnerabilities.SAST.high}, Medium: ${vulnerabilities.SAST.medium}, Low: ${vulnerabilities.SAST.low}"
                        echo "   SCA - Critical: ${vulnerabilities.SCA.critical}, High: ${vulnerabilities.SCA.high}, Medium: ${vulnerabilities.SCA.medium}, Low: ${vulnerabilities.SCA.low}"
                        
                        echo "üìã Capturing Checkmarx SARIF report..."
                        
                        // Capture SARIF file content
                        def sarifContent = sh(script: '''
                            if [ -f "reports/checkmarx.sarif" ]; then
                                echo "SARIF_FOUND"
                                cat "reports/checkmarx.sarif"
                            else
                                echo "SARIF_NOT_FOUND"
                            fi
                        ''', returnStdout: true).trim()
                        
                        // Store SARIF content in environment variable
                        def sarifNotFound = "SARIF_NOT_FOUND"
                        def sarifFound = "SARIF_FOUND"
                        
                        if (sarifContent != sarifNotFound && sarifContent.startsWith(sarifFound)) {
                            env.CHECKMARX_SARIF_REPORT = sarifContent.substring(sarifContent.indexOf('\n') + 1)
                            echo "‚úÖ SARIF report captured (${env.CHECKMARX_SARIF_REPORT.length()} characters)"
                        } else {
                            echo "‚ùå SARIF report not found"
                            env.CHECKMARX_SARIF_REPORT = null
                        }
                        
                        // Archive reports for backup
                        archiveArtifacts artifacts: 'reports/**', fingerprint: true
                        
                    } catch (Exception e) {
                        echo "‚ùå Checkmarx scan failed: ${e.getMessage()}"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    sh '''
                        echo "Building backend Docker image..."
                        docker build --no-cache -t $IMAGE_NAME_BACKEND:$IMAGE_TAG .
                        docker images | grep $IMAGE_NAME_BACKEND
                    '''
                }
            }
        }

        stage('Send to n8n & Download HTML back') {
            steps {
                script {
                    // Create reports directory with proper permissions
                    sh '''
                        mkdir reports 2>/dev/null || true
                        chmod 755 reports 2>/dev/null || true
                    '''
                    
                    def jobResult = currentBuild.result ?: 'SUCCESS'
                    def failedStage = 'None'
                    
                    if (jobResult != 'SUCCESS') {
                        failedStage = env.STAGE_NAME ?: 'Unknown Stage'
                    }

                    def bangkokTimeZone = TimeZone.getTimeZone('Asia/Bangkok')
                    def dateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
                    dateFormat.setTimeZone(bangkokTimeZone)
                    
                    def checkmarxReport = null
                    def checkmarxScanSummary = null
                    
                    if (params.Run_Checkmarx) {
                        echo "üîç Processing Checkmarx SARIF report..."
                        
                        try {
                            // Parse scan summary from environment variable
                            if (env.CHECKMARX_SCAN_SUMMARY) {
                                checkmarxScanSummary = new groovy.json.JsonSlurperClassic().parseText(env.CHECKMARX_SCAN_SUMMARY)
                                echo "‚úÖ Scan summary parsed successfully"
                            }
                            
                            if (env.CHECKMARX_SARIF_REPORT && env.CHECKMARX_SARIF_REPORT != 'null') {
                                // Send raw SARIF content without parsing to avoid readJSON dependency
                                checkmarxReport = [
                                    format: 'sarif',
                                    content: env.CHECKMARX_SARIF_REPORT,
                                    summary: checkmarxScanSummary ?: 'Checkmarx AST scan results in SARIF format',
                                    filePath: 'reports/checkmarx.sarif',
                                    fileSize: env.CHECKMARX_SARIF_REPORT.length(),
                                    captureMethod: 'file_content'
                                ]
                                echo "‚úÖ SARIF report captured (${env.CHECKMARX_SARIF_REPORT.length()} characters)"
                            } else {
                                checkmarxReport = [
                                    format: 'error',
                                    content: null,
                                    summary: checkmarxScanSummary ?: 'SARIF report was not captured - file may not exist',
                                    captureMethod: 'failed'
                                ]
                                echo "‚ùå No SARIF report was captured"
                            }
                        } catch (Exception e) {
                            checkmarxReport = [
                                format: 'error',
                                content: null,
                                summary: checkmarxScanSummary ?: ('Error processing SARIF report: ' + e.getMessage()),
                                exception: e.getClass().getSimpleName()
                            ]
                            echo "‚ùå Error processing SARIF report: ${e.getMessage()}"
                        }
                    } else {
                        echo "‚è≠Ô∏è Checkmarx scan was skipped"
                    }

                    def payload = [
                        jobName: env.JOB_NAME,
                        buildNumber: env.BUILD_NUMBER,
                        jobResult: jobResult,
                        isSuccess: jobResult == 'SUCCESS',
                        triggeredBy: currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')?.get(0)?.userId ?: 'System',
                        startTime: dateFormat.format(new Date(currentBuild.startTimeInMillis)),
                        endTime: dateFormat.format(new Date()),
                        duration: currentBuild.durationString,
                        failedStage: failedStage,
                        timezone: 'Asia/Bangkok',
                        repository: [
                            url: params.REPO_URL,
                            branch: params.REPO_BRANCH
                        ],
                        buildUrl: env.BUILD_URL,
                        parameters: [
                            imageName: params.IMAGE_NAME_BACKEND,
                            runCheckmarx: params.Run_Checkmarx
                        ],
                        checkmarxReport: checkmarxReport,
                        checkmarxScanSummary: checkmarxScanSummary
                    ]

                // Send data to n8n and get HTML report in response
                def buildNumber = env.BUILD_NUMBER
                def expectedFileName = "Report-jenkins-checkmarx-test-build-${buildNumber}.html"
                def outFile = "reports/${expectedFileName}"
                
                try {
                    echo "ÔøΩ Sending data to n8n and waiting for HTML report response..."
                    
                    // Send request and save response directly to file
                    def res = httpRequest(
                        httpMode: 'POST',
                        url: params.N8N_WEBHOOK_URL,
                        contentType: 'APPLICATION_JSON',
                        requestBody: groovy.json.JsonOutput.toJson(payload),
                        timeout: 300,  // 5 minutes timeout for n8n to process and respond
                        ignoreSslErrors: true,
                        validResponseCodes: '200:299',
                        outputFile: outFile  // Save response directly to file
                    )
                    
                    echo "‚úÖ Response received from n8n - Status: ${res.status}"
                    
                    // Check if we got valid HTML content
                    def fileContent = readFile(outFile)
                    
                    if (fileContent.contains('<html') || fileContent.contains('<!DOCTYPE')) {
                        echo "‚úÖ Valid HTML report received! Size: ${fileContent.length()} characters"
                        
                        // Archive the HTML report
                        archiveArtifacts artifacts: outFile, fingerprint: true, onlyIfSuccessful: false
                        echo "üìÅ Report archived as Jenkins artifact: ${outFile}"
                        echo "üéâ HTML report successfully received and archived!"
                        
                    } else {
                        echo "‚ö†Ô∏è Response received but doesn't contain valid HTML"
                        echo "ÔøΩ Response preview (first 500 chars):"
                        echo fileContent.take(500)
                    }
                    
                } catch (Exception e) {
                    echo "‚ùå Failed to get HTML from n8n: ${e.getMessage()}"
                    if (e.getMessage().contains('SSL') || e.getMessage().contains('certificate')) {
                        echo "Note: SSL certificate issue with self-signed certificates"
                    } else if (e.getMessage().contains('timeout')) {
                        echo "Note: n8n took too long to generate the report (> 5 minutes)"
                    }
                }
                
                // Send data to Datadog
                try {
                    def triggeredBy = currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')?.get(0)?.userId ?: 'System'
                    def buildDurationSeconds = (currentBuild.duration ?: 0) / 1000.0
                    def statusValue = jobResult == 'SUCCESS' ? 1 : 0
                    
                    def tags = [
                        "job_name:${env.JOB_NAME}",
                        "branch:${params.REPO_BRANCH}",
                        "result:${jobResult.toLowerCase()}",
                        "user:${triggeredBy}",
                        "env:production",
                        "service:community-platform-backend"
                    ]
                    
                    // Send data to Datadog using plugin
                    datadog(collectLogs: true, tags: tags) {
                        // Log structured data for Datadog to collect
                        echo "DATADOG_METRIC: jenkins.job.duration=${buildDurationSeconds} type=gauge"
                        echo "DATADOG_METRIC: jenkins.job.status=${statusValue} type=gauge" 
                        echo "DATADOG_METRIC: jenkins.job.completed=1 type=count"
                        
                        // Send standard logs
                        echo "Build: ${env.JOB_NAME} #${env.BUILD_NUMBER} - ${jobResult}"
                        echo "User: ${triggeredBy}, Duration: ${buildDurationSeconds}s, Branch: ${params.REPO_BRANCH}"
                        
                        if (params.Run_Checkmarx && checkmarxScanSummary) {
                            echo "Checkmarx scan completed - Risk Level: ${checkmarxScanSummary.riskLevel ?: 'Unknown'}"
                            echo "Vulnerabilities - Critical: ${checkmarxScanSummary.totalCritical ?: 0}, High: ${checkmarxScanSummary.totalHigh ?: 0}, Medium: ${checkmarxScanSummary.totalMedium ?: 0}, Low: ${checkmarxScanSummary.totalLow ?: 0}"
                            
                            // Send Checkmarx metrics to Datadog
                            echo "DATADOG_METRIC: jenkins.checkmarx.critical=${checkmarxScanSummary.totalCritical ?: 0} type=gauge scan_type=checkmarx"
                            echo "DATADOG_METRIC: jenkins.checkmarx.high=${checkmarxScanSummary.totalHigh ?: 0} type=gauge scan_type=checkmarx"
                            echo "DATADOG_METRIC: jenkins.checkmarx.medium=${checkmarxScanSummary.totalMedium ?: 0} type=gauge scan_type=checkmarx"
                            echo "DATADOG_METRIC: jenkins.checkmarx.low=${checkmarxScanSummary.totalLow ?: 0} type=gauge scan_type=checkmarx"
                            
                            // Send SAST metrics
                            if (checkmarxScanSummary.vulnerabilities?.SAST) {
                                def sast = checkmarxScanSummary.vulnerabilities.SAST
                                echo "DATADOG_METRIC: jenkins.checkmarx.sast.critical=${sast.critical ?: 0} type=gauge scan_type=sast"
                                echo "DATADOG_METRIC: jenkins.checkmarx.sast.high=${sast.high ?: 0} type=gauge scan_type=sast"
                                echo "DATADOG_METRIC: jenkins.checkmarx.sast.medium=${sast.medium ?: 0} type=gauge scan_type=sast"
                                echo "DATADOG_METRIC: jenkins.checkmarx.sast.low=${sast.low ?: 0} type=gauge scan_type=sast"
                            }
                            
                            // Send SCA metrics
                            if (checkmarxScanSummary.vulnerabilities?.SCA) {
                                def sca = checkmarxScanSummary.vulnerabilities.SCA
                                echo "DATADOG_METRIC: jenkins.checkmarx.sca.critical=${sca.critical ?: 0} type=gauge scan_type=sca"
                                echo "DATADOG_METRIC: jenkins.checkmarx.sca.high=${sca.high ?: 0} type=gauge scan_type=sca"
                                echo "DATADOG_METRIC: jenkins.checkmarx.sca.medium=${sca.medium ?: 0} type=gauge scan_type=sca"
                                echo "DATADOG_METRIC: jenkins.checkmarx.sca.low=${sca.low ?: 0} type=gauge scan_type=sca"
                            }
                        }
                        
                        if (params.Run_Checkmarx && checkmarxReport?.fileSize) {
                            echo "DATADOG_METRIC: jenkins.checkmarx.report_size=${checkmarxReport.fileSize} type=gauge scan_type=checkmarx"
                        }
                    }
                    echo "‚úÖ Data sent to Datadog successfully"
                } catch (Exception e) {
                    echo "‚ùå Failed to send data to Datadog: ${e.getMessage()}"
                }
            }
        }
    }
}
