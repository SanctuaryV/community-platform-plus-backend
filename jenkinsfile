pipeline {
    agent any

    parameters {
        string(name: 'REPO_URL', defaultValue: 'https://github.com/SanctuaryV/community-platform-plus-backend.git', description: 'Git repo URL')
        string(name: 'REPO_BRANCH', defaultValue: 'main', description: 'Branch to checkout')
        string(name: 'IMAGE_NAME_BACKEND', defaultValue: 'community-platform-plus-backend', description: 'Docker image name for backend')
        string(name: 'N8N_WEBHOOK_URL', defaultValue: 'https://35.247.160.122:5678/webhook/627982e1-ee55-4a89-a91a-901e8436b313', description: 'n8n Test Webhook URL')
        booleanParam(name: 'Run_Checkmarx', defaultValue: false, description: 'Run Checkmarx scan')
    }

    environment {
        APP_REPO_URL     = "${params.REPO_URL}"
        APP_REPO_BRANCH  = "${params.REPO_BRANCH}"
        IMAGE_NAME_BACKEND = "${params.IMAGE_NAME_BACKEND}"
        IMAGE_TAG        = "${BUILD_NUMBER}"

        // üëá ‡∏ï‡∏±‡πâ‡∏á Datadog site ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á region (us: datadoghq.com, eu: datadoghq.eu, ap1: ap1.datadoghq.com)
        //DD_SITE          = "datadoghq.com"
        // ‡∏ñ‡πâ‡∏≤‡πÉ‡∏ä‡πâ Agent/CI Visibility ‡∏Å‡πá‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ DD_AGENT_HOST, DD_TRACE_AGENT_PORT ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ
        // DD_AGENT_HOST  = "datadog-agent.default.svc.cluster.local"
        // DD_TRACE_AGENT_PORT = "8126"
    }

    stages {
        stage('Clone Repository') {
            steps {
                cleanWs()
                git branch: "${APP_REPO_BRANCH}",
                    url: "${APP_REPO_URL}"
            }
        }

        stage('Install Dependencies') {
            steps {
                sh '''
                    echo "Installing dependencies..."
                    npm install
                '''
            }
        }

        stage('SAST - Checkmarx') {
            when {
                expression { return params.Run_Checkmarx == true }
            }
            steps {
                script {
                    try {
                        echo "üîç Running Checkmarx scan..."

                        // Run Checkmarx scan with custom output path
                        checkmarxASTScanner additionalOptions: '--project-groups intern --scan-types "sast,sca" --report-format sarif --output-name checkmarx --output-path reports',
                            baseAuthUrl: '',
                            branchName: "${APP_REPO_BRANCH}",
                            checkmarxInstallation: 'Checkmarx',
                            credentialsId: '',
                            projectName: "SanctuaryV/community-platform-plus-backend",
                            serverUrl: '',
                            tenantName: '',
                            useOwnAdditionalOptions: true

                        echo "üìã Capturing Checkmarx SARIF report..."

                        // Capture SARIF file content
                        def sarifContent = sh(script: '''
                            if [ -f "reports/checkmarx.sarif" ]; then
                                echo "SARIF_FOUND"
                                cat "reports/checkmarx.sarif"
                            else
                                echo "SARIF_NOT_FOUND"
                            fi
                        ''', returnStdout: true).trim()

                        // Store SARIF content in environment variable
                        def sarifNotFound = "SARIF_NOT_FOUND"
                        def sarifFound = "SARIF_FOUND"

                        if (sarifContent != sarifNotFound && sarifContent.startsWith(sarifFound)) {
                            env.CHECKMARX_SARIF_REPORT = sarifContent.substring(sarifContent.indexOf('\n') + 1)
                            echo "‚úÖ SARIF report captured (${env.CHECKMARX_SARIF_REPORT.length()} characters)"
                        } else {
                            echo "‚ùå SARIF report not found"
                            env.CHECKMARX_SARIF_REPORT = null
                        }

                        // Archive reports for backup
                        archiveArtifacts artifacts: 'reports/**', fingerprint: true

                    } catch (Exception e) {
                        echo "‚ùå Checkmarx scan failed: ${e.getMessage()}"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    sh '''
                        echo "Building backend Docker image..."
                        docker build --no-cache -t $IMAGE_NAME_BACKEND:$IMAGE_TAG .
                        docker images | grep $IMAGE_NAME_BACKEND
                    '''
                }
            }
        }
    }

    post {
        always {
            script {
                def jobResult = currentBuild.result ?: 'SUCCESS'
                def failedStage = 'None'

                if (jobResult != 'SUCCESS') {
                    failedStage = env.STAGE_NAME ?: 'Unknown Stage'
                }

                def bangkokTimeZone = TimeZone.getTimeZone('Asia/Bangkok')
                def dateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
                dateFormat.setTimeZone(bangkokTimeZone)

                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì duration ‡πÄ‡∏õ‡πá‡∏ô‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡πÅ‡∏°‡πà‡∏ô‡∏Å‡∏ß‡πà‡∏≤ durationString)
                long endMillis = System.currentTimeMillis()
                long startMillis = currentBuild.startTimeInMillis ?: (endMillis - 1)
                long durationSec = Math.max(1L, (endMillis - startMillis) / 1000L)

                def checkmarxReport = null
                def findingsCount = 0

                if (params.Run_Checkmarx) {
                    echo "üîç Processing Checkmarx SARIF report..."

                    try {
                        if (env.CHECKMARX_SARIF_REPORT && env.CHECKMARX_SARIF_REPORT != 'null') {
                            // Parse SARIF content as JSON to validate and get summary info
                            def sarifData = readJSON text: env.CHECKMARX_SARIF_REPORT
                            def runInfo = sarifData.runs ? sarifData.runs[0] : null
                            findingsCount = (runInfo && runInfo.results) ? runInfo.results.size() : 0

                            checkmarxReport = [
                                format: 'sarif',
                                content: env.CHECKMARX_SARIF_REPORT,
                                summary: "Checkmarx AST scan results in SARIF format with ${findingsCount} findings",
                                filePath: 'reports/checkmarx.sarif',
                                fileSize: env.CHECKMARX_SARIF_REPORT.length(),
                                resultsCount: findingsCount,
                                captureMethod: 'file_content'
                            ]
                            echo "‚úÖ SARIF report processed: ${findingsCount} findings found"
                        } else {
                            checkmarxReport = [
                                format: 'error',
                                content: null,
                                summary: 'SARIF report was not captured - file may not exist',
                                captureMethod: 'failed'
                            ]
                            echo "‚ùå No SARIF report was captured"
                        }
                    } catch (Exception e) {
                        checkmarxReport = [
                            format: 'error',
                            content: null,
                            summary: 'Error processing SARIF report: ' + e.getMessage(),
                            exception: e.getClass().getSimpleName()
                        ]
                        echo "‚ùå Error processing SARIF report: ${e.getMessage()}"
                    }
                } else {
                    echo "‚è≠Ô∏è Checkmarx scan was skipped"
                }

                def payload = [
                    jobName     : env.JOB_NAME,
                    buildNumber : env.BUILD_NUMBER,
                    jobResult   : jobResult,
                    isSuccess   : jobResult == 'SUCCESS',
                    triggeredBy : currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')?.get(0)?.userId ?: 'System',
                    startTime   : dateFormat.format(new Date(startMillis)),
                    endTime     : dateFormat.format(new Date(endMillis)),
                    duration    : "${durationSec}s",
                    failedStage : failedStage,
                    timezone    : 'Asia/Bangkok',
                    repository  : [
                        url   : params.REPO_URL,
                        branch: params.REPO_BRANCH
                    ],
                    buildUrl    : env.BUILD_URL,
                    parameters  : [
                        imageName  : params.IMAGE_NAME_BACKEND,
                        runCheckmarx: params.Run_Checkmarx
                    ],
                    checkmarxReport: checkmarxReport
                ]

                /***************
                 * Datadog: ‡∏™‡πà‡∏á Event + Metrics
                 ***************/
                try {
                    withCredentials([string(credentialsId: 'DATADOG_API_KEY', variable: 'DD_API_KEY')]) {

                        // 1) ‡∏™‡πà‡∏á Event ‡πÄ‡∏Ç‡πâ‡∏≤ Datadog Event Stream
                        def ddEvent = [
                            title          : "Jenkins ${env.JOB_NAME} #${env.BUILD_NUMBER} ${payload.isSuccess ? 'SUCCESS' : 'FAILED'}",
                            text           : """\
**Result**: ${payload.jobResult}
**Repo**: ${payload.repository.url} (${payload.repository.branch})
**Duration**: ${payload.duration}
**Build URL**: ${payload.buildUrl}
${payload.checkmarxReport ? "**Checkmarx**: ${payload.checkmarxReport.summary}" : ""}
""".stripIndent(),
                            tags           : [
                                "service:community-platform-plus-backend",
                                "env:ci",
                                "jenkins_job:${env.JOB_NAME}",
                                "branch:${params.REPO_BRANCH}",
                                "result:${payload.jobResult.toLowerCase()}",
                                "run_checkmarx:${params.Run_Checkmarx}"
                            ],
                            alert_type     : (payload.isSuccess ? "success" : "error"),
                            aggregation_key: "jenkins:${env.JOB_NAME}"
                        ]

                        def site = env.DD_SITE ?: "datadoghq.com"

                        httpRequest(
                            httpMode: 'POST',
                            url: "https://api.${site}/api/v1/events",
                            customHeaders: [
                                [name: 'Content-Type', value: 'application/json'],
                                [name: 'DD-API-KEY', value: "${env.DD_API_KEY}"]
                            ],
                            requestBody: groovy.json.JsonOutput.toJson(ddEvent),
                            validResponseCodes: '200:299',
                            consoleLogResponseBody: false,
                            timeout: 30
                        )
                        echo "‚úÖ Datadog event sent"
                        // 2) ‡∏™‡πà‡∏á Metrics (build duration + findings count) ‡πÄ‡∏Ç‡πâ‡∏≤ Metrics API v2
                        // ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: submit metrics ‡πÉ‡∏ä‡πâ API Key ‡∏û‡∏≠ ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á App Key
                        def nowSec = (long)(System.currentTimeMillis() / 1000L)
                        def ddSeries = [
                            series: [
                                [
                                    metric: "jenkins.build.duration",
                                    points: [[nowSec, durationSec]],
                                    type  :  "gauge",
                                    tags  : [
                                        "service:community-platform-plus-backend",
                                        "env:ci",
                                        "jenkins_job:${env.JOB_NAME}",
                                        "branch:${params.REPO_BRANCH}",
                                        "result:${payload.jobResult.toLowerCase()}"
                                    ]
                                ],
                                [
                                    metric: "jenkins.checkmarx.findings",
                                    points: [[nowSec, findingsCount]],
                                    type  :  "gauge",
                                    tags  : [
                                        "service:community-platform-plus-backend",
                                        "env:ci",
                                        "jenkins_job:${env.JOB_NAME}",
                                        "branch:${params.REPO_BRANCH}"
                                    ]
                                ]
                            ]
                        ]

                        httpRequest(
                            httpMode: 'POST',
                            url: "https://api.${site}/api/v2/series",
                            customHeaders: [
                                [name: 'Content-Type', value: 'application/json'],
                                [name: 'DD-API-KEY', value: "${env.DD_API_KEY}"]
                            ],
                            requestBody: groovy.json.JsonOutput.toJson(ddSeries),
                            validResponseCodes: '200:299',
                            consoleLogResponseBody: false,
                            timeout: 30
                        )
                        echo "‚úÖ Datadog metrics sent"
                    }
                } catch (Exception e) {
                    echo "‚ùå Datadog send failed: ${e.getMessage()}"
                }

                /***************
                 * ‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°: ‡∏¢‡∏¥‡∏á webhook ‡πÑ‡∏õ n8n
                 ***************/
                try {
                    httpRequest(
                        httpMode: 'POST',
                        url: params.N8N_WEBHOOK_URL,
                        contentType: 'APPLICATION_JSON',
                        requestBody: groovy.json.JsonOutput.toJson(payload),
                        timeout: 30,
                        ignoreSslErrors: true,
                        acceptType: 'APPLICATION_JSON',
                        validResponseCodes: '200:299',
                        quiet: false
                    )
                    echo "‚úÖ Webhook sent to n8n successfully"
                } catch (Exception e) {
                    echo "‚ùå Failed to send webhook to n8n: ${e.getMessage()}"
                    if (e.getMessage().contains('SSL') || e.getMessage().contains('certificate')) {
                        echo "Note: SSL certificate issue with self-signed certificates"
                    }
                }
            }
        }
    }
}
